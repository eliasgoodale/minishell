https://brennan.io/2015/01/16/write-a-shell-in-c/
https://www.geeksforgeeks.org/making-linux-shell-c/
https://stackoverflow.com/questions/4788374/writing-a-basic-shell
https://www.cs.purdue.edu/homes/grr/SystemsProgrammingBook/Book/Chapter5-WritingYourOwnShell.pdf
https://indradhanush.github.io/blog/writing-a-unix-shell-part-1/
https://www.cs.cornell.edu/courses/cs414/2004su/homework/shell/shell.html
http://linuxcommand.org/lc3_wss0010.php
http://linuxcommand.org/lc3_writing_shell_scripts.php
Read APUE Chapter 8 (Process Control). Read it again. Write a program that:
fork()s a new process,
exec()s the /bin/echo program with the two arguments "Hello" and "world!",
wait()s for the child process to complete, then
returns the result from wait().
Run this program; it should print "Hello world!" and return 0. Do not proceed any further until you've gotten this to work; it would be completely pointless if your shell can't even run a simple executable from a fully-qualified pathname.

I/O redirection simply involves open()ing the specified file, then replacing standard input/output/error with the resulting file descriptor using dup2().

Pipes simply involve calls to pipe(), followed by the appropriate I/O redirection on the two processes you're connecting with that pipe.

Unless you already know that wildcard expansion is called "globbing" in the Unix world, you'd never think to look for a prebuilt function like glob() to do the heavy lifting.


SHELL DATA STRUCTURE

Shell deals with two main data types:
SINGLE PROCESS:

typedef struct s_process
{
    struct s_process *next;
    char **av;
    pid_t pid;
    char completed;
    char stopped;
    int status;
}               t_process;

JOBS(PIPELINE OF PROCESSES)

typedef struct s_job
{
    struct s_job *next;
    char *command;
    process *first_process;
    pid_t pgid;
    char notified;
    struct termios tmodes;
    int stdin, stdout, stderr;
}               t_job;


UTILITY FUNCTIONS TO WORK ON THESE DATA STRUCTURES

t_job *first_job = NULL;

when you have a list of jobs to look through:

t_job       *find_job(pid_t pgid, t_job **first_job)
{
    t_job *j;

    j = *first_job
    while(j)
    {
        if(j->pgid == pgid)
            return(j);
        j = j->next;
    }
    return (NULL);
}


int         job_is_stopped(t_job *j)
{
    process *p;

    p = j->first_process;
    while (p)
    {
        if(!p->completed && !p->stopped)
            return (0);
        p = p->next
    }
    return (1);
}

int         job_is_completed(t_job *j)
{
    process *p;

    p = j->first_process;
    while(p)
    {
        if(!p->completed)
            return (0);
        p = p->next;
    }
    return (1);
}

Launching a job:
    > 











typedef struct FAST_16field
{
    FAST_64_TYPE f1 : 8
    FAST_64_TYPE fspace: 0
    FAST_64_TYPE f24 : 4
}














